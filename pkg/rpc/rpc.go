// Package `rpc` exports methods to interface with an RPC server.
//
// This separation allows RPC clients to not require importing the `server`
// package, which makes them a lot lighter.
//
// The "Impl" variables are to be used by the server for the internal implementations
// of each RPC opeartion.
package rpc

import (
	"fmt"
	"net/http"
	"net/rpc"
	"time"
)

// The interface RPC servers must implement.
type Implementation interface {
	AddAuth(args *AddAuthArgs, reply *int) error
	RmAuth(args *RmAuthArgs, reply *int) error
}

// Wraps the HTTP server generated by the implementation.
type Server struct {
	HTTP  *http.Server
	impl   Implementation
}

// Arguments for the AddAuth operation.
type AddAuthArgs struct {
	Username string
	Password string
	Role     string
}

// Arguments for the RmAuth operation.
type RmAuthArgs struct {
	Username string
}

// Returns an HTTP server that serves RPC in the passed port.
// The "Impl" variables should be used to configure its operations
// before running the server.
// If there is an issue setting up the server, returns an error.
func NewServer(impl Implementation, port int) (*Server, error) {
    srv := new(Server)
	s := rpc.NewServer()
	if err := s.Register(srv); err != nil {
		return nil, err
	}

    srv.HTTP = &http.Server{
		Addr:           fmt.Sprintf("localhost:%v", port),
		Handler:        s,
		ReadTimeout:    10 * time.Second,
		WriteTimeout:   10 * time.Second,
		MaxHeaderBytes: 1 << 20,
	}
    srv.impl = impl
    return srv, nil
}

// Adds an user to the auth table in the database.
func (srv *Server) AddAuth(args *AddAuthArgs, reply *int) error {
	return srv.impl.AddAuth(args, reply)
}

// Removes an user from the auth table in the database.
func (srv *Server) RmAuth(args *RmAuthArgs, reply *int) error {
	return srv.impl.RmAuth(args, reply)
}
